X2 <- x2
X3 <- x3
X4 <- x4
X5 <- x5
pm = rep(0, D)
pm = 1/(1+exp(-theta_zero_M - theta_X1M * X1- theta_X2M * X2- theta_X3M * X3- theta_X4M * X4- theta_X5M * X5))
M <- rbinom(n = D, size = 1, prob = pm)
py = rep(0, D)
py = 1/(1+exp(-theta_zero_Y - theta_MY * M - theta_U1Y * U1 - theta_U2Y * U2 - theta_U3Y * U3))
Y <- rbinom(n = D, size = 1, prob = py)
intv_data_list[[data_count]] <- data.frame("U1" = U1,"U2" = U2, "U3" = U3, "X1" = X1, "X2" = X2,"X3" = X3,"X4" = X4,"X5" = X5, "M" = M, "Y" = Y)
data_count = data_count + 1
}
model_str <- "
data {
int D;
int<lower=0,upper=1> X1[D];
int<lower=0,upper=1> X2[D];
int<lower=0,upper=1> X3[D];
int<lower=0,upper=1> X4[D];
int<lower=0,upper=1> X5[D];
int<lower=0,upper=1> M[D];
int<lower=0,upper=1> Y[D];
}
parameters {
real<lower=0> u1_scale;
real<lower=0> mu1;
real<lower=0> u2_scale;
real mu2;
real<lower=0> u3_scale;
real mu3;
real theta_zero_X1;
real theta_U1X1;
real theta_U2X1;
real theta_U3X1;
real theta_zero_X2;
real theta_U1X2;
real theta_U2X2;
real theta_U3X2;
real theta_zero_X3;
real theta_U1X3;
real theta_U2X3;
real theta_U3X3;
real theta_zero_X4;
real theta_U1X4;
real theta_U2X4;
real theta_U3X4;
real theta_zero_X5;
real theta_U1X5;
real theta_U2X5;
real theta_U3X5;
real theta_zero_M;
real theta_X1M;
real theta_X2M;
real theta_X3M;
real theta_X4M;
real theta_X5M;
real theta_zero_Y;
real theta_MY;
real theta_U1Y;
real theta_U2Y;
real theta_U3Y;
vector[D] U1;
vector[D] U2;
vector[D] U3;
}
model {
//prior over parameters
u1_scale  ~ normal(0, 10);
u2_scale  ~ normal(0, 10);
u3_scale  ~ normal(0, 10);
mu1  ~ normal(0, 10);
mu2  ~ normal(0, 10);
mu3 ~ normal(0, 10);
theta_zero_X1  ~ normal(0, 10);
theta_U1X1 ~ normal(0, 10);
theta_U2X1 ~ normal(0, 10);
theta_U3X1 ~ normal(0, 10);
theta_zero_X2  ~ normal(0, 10);
theta_U1X2 ~ normal(0, 10);
theta_U2X2 ~ normal(0, 10);
theta_U3X2 ~ normal(0, 10);
theta_zero_X3  ~ normal(0, 10);
theta_U1X3 ~ normal(0, 10);
theta_U2X3 ~ normal(0, 10);
theta_U3X3 ~ normal(0, 10);
theta_zero_X4  ~ normal(0, 10);
theta_U1X4 ~ normal(0, 10);
theta_U2X4 ~ normal(0, 10);
theta_U3X4 ~ normal(0, 10);
theta_zero_X5  ~ normal(0, 10);
theta_U1X5 ~ normal(0, 10);
theta_U2X5 ~ normal(0, 10);
theta_U3X5 ~ normal(0, 10);
theta_zero_M ~ normal(0, 10);
theta_X1M ~ normal(0, 10);
theta_X2M ~ normal(0, 10);
theta_X3M ~ normal(0, 10);
theta_X4M ~ normal(0, 10);
theta_X5M ~ normal(0, 10);
theta_zero_Y ~ normal(0, 10);
theta_MY ~ normal(0, 10);
theta_U1Y ~ normal(0, 10);
theta_U2Y ~ normal(0, 10);
theta_U3Y ~ normal(0, 10);
//likelihood
U1 ~ normal(mu1, u1_scale);
U2 ~ normal(mu2, u2_scale);
U3 ~ normal(mu3, u3_scale);
X1 ~ bernoulli_logit(theta_zero_X1 + theta_U1X1 * U1 + theta_U2X1 * U2 + theta_U3X1 * U3);
X2 ~ bernoulli_logit(theta_zero_X2 + theta_U1X2 * U1 + theta_U2X2 * U2 + theta_U3X2 * U3);
X3 ~ bernoulli_logit(theta_zero_X3 + theta_U1X3 * U1 + theta_U2X3 * U2 + theta_U3X3 * U3);
X4 ~ bernoulli_logit(theta_zero_X4 + theta_U1X4 * U1 + theta_U2X4 * U2 + theta_U3X4 * U3);
X5 ~ bernoulli_logit(theta_zero_X5 + theta_U1X5 * U1 + theta_U2X5 * U2 + theta_U3X5 * U3);
for(i in 1:D) {
M[i] ~ bernoulli_logit(theta_zero_M + theta_X1M * X1[i] + theta_X2M * X2[i] + theta_X3M * X3[i] + theta_X4M * X4[i] + theta_X5M * X5[i]);
Y[i] ~ bernoulli_logit(theta_zero_Y + theta_MY * M[i] + theta_U1Y * U1[i] + theta_U2Y * U2[i] + theta_U3Y * U3[i]);
}
}
"
mod <- rstan::stan_model(model_code = model_str)
# Load data
#GRN <- read.table("~/Missing data/SERGIO/Demo/differentiation_input_GRN.txt", quote="\"", comment.char="")
GRN <- read.table("~/Missing data/SERGIO/Demo/single_cell_GRN.txt", quote="\"", comment.char="")
GRN_out <- read.csv("~/Missing data/SERGIO/Demo/GeneExpression.csv")
###############
### Input #####
###############
relationships <- list()# open the file
paths <- list()
# split the line into child and parents
for (line in 1:nrow(GRN)) {
line_elements <- strsplit(GRN[line,], ",") [[1]]
#child <- as.character(as.numeric(line_elements[1]))
child <- line_elements[1]
child <- paste0("Gene",child)
Num.regs <- as.numeric(line_elements[2])
parents <- strsplit(line_elements[3:(2+Num.regs)]," ")
#parents <-lapply(parents,as.numeric)
parents <-lapply(parents,as.character)
for (parent in parents) {
if (!(parent %in% names(relationships))) {
relationships[[parent]] <- list()
}
relationships[[parent]] <- c(relationships[[parent]], child)
#relationships[[parent]] <-lapply(relationships[[parent]],as.numeric)
}
}
relationships
# create the paths
paths <- list()
for (parent in names(relationships)) {
for (child in relationships[[parent]]) {
path <- child
current <- child
while (current %in% names(relationships)) {
print(current[[1]])
current <- relationships[[current]][[1]]
print(current[[1]])
path <- paste0(current,"-" ,path)
print("itr")
}
path <- paste0(path,"-",parent)
print("itrchild")
paths <- c(paths, path)
}
}
paths
View(GRN_out)
# Use daggity network to obtain conditional independance #
########################################################
library(dagitty)
library(lavaan)
library(sna)
library(DOT)
library(Rgraphviz)
BiocManager::install("graph")
library(pcalg)
install.packages("pcalg")
library(pcalg)
BiocManager::install("RBGL")
install.packages("pcalg")
library(pcalg)
dot <- read.dot("~/Missing data/SERGIO/GNW_sampled_GRNs/Ecoli_100_net1.dot")
g.graph <- graph.adjacency(dot)
########################################################
library(dagitty)
library(lavaan)
library(sna)
library(DOT)
library(Rgraphviz)
library(igraph)
library(pcalg)
dot <- read.dot("~/Missing data/SERGIO/GNW_sampled_GRNs/Ecoli_100_net1.dot")
g.graph <- graph.adjacency(dot)
plot(g.graph)
g.graph
?g.graph
?graph.adjacency
V <- colnames(dot$x)
dot
dot
pcalg2dagitty(dot,type = "cpdag")
g.graph <- graph.adjacency(dot)
plot(g.graph)
str(g.graph)
G <- graph2dagitty(g.graph)
install.packages("SEMgraph")
library(SEMgrapgh)
library(SEMgragh)
library(SEMgraph)
G <- graph2dagitty(g.graph)
G
str(G)
impliedConditionalIndependencies(G, type = "missing.edge", max.results = Inf)
plot( graphLayout(G) )
g <- graph2dagitty(g.graph)
plot( graphLayout(g) )
# plot
impliedConditionalIndependencies(G, type = "missing.edge", max.results = Inf)
# draw paths
paths(g, "X", "T" )$paths
# draw paths
paths(g, "icd", "fadl" )$paths
# draw paths
paths(g, "icd", "fadI" )$paths
# plot
impliedConditionalIndependencies(g, type = "missing.edge", max.results = Inf)
# Draw directed paths from icd to fadI
paths(g, "icd", "fadI",directed=TRUE  )$paths
# Draw directed paths from icd to fadI
paths(g, "icd", "fadI", directed=TRUE)$paths
# Draw directed paths from icd to fadI
paths(g, "yeaH", "yhdW", directed=TRUE)$paths
# Draw directed paths from icd to fadI
paths(g, "potL", "nemA", directed=TRUE)$paths
# Draw directed paths from icd to fadI
paths(g, "potI", "nemA", directed=TRUE)$paths
N <- 10000 # sample size
Ux <- rnorm( N ); Uy <- rnorm( N ); Uz <- rnorm( N )
X <- Ux
Y <- 1/3*X + Uy
Z <- 1/16*Y + Uz
d <- data.frame(X=X,Y=Y,Z=Z)
N <- 10000 # sample size
Ux <- rnorm( N )
Uy <- rnorm( N )
Uz <- rnorm( N )
X <- Ux
Y <- 1/3*X + Uy
Z <- 1/16*Y + Uz
d <- data.frame(X=X,Y=Y,Z=Z)
coordinates(g) <- list(
x=c(Ux=1,Uy=2,Uz=3,X=1,Y=2,Z=3),
y=c(Ux=1,Uy=1,Uz=1,X=0,Y=0,Z=0) )
plot(g)
g <- dagitty("dag {
Ux -> X -> Y -> Z <- Uz
Uy -> Y
}")
coordinates(g) <- list(
x=c(Ux=1,Uy=2,Uz=3,X=1,Y=2,Z=3),
y=c(Ux=1,Uy=1,Uz=1,X=0,Y=0,Z=0) )
plot(g)
impliedConditionalIndependencies(g, type = "missing.edge", max.results = Inf)
pairs <- combn( names( g), 2 )
apply( pairs, 2, function(x){
all.other.variables <- setdiff( names(g), x )
if( dseparated(g, x[1], x[2], all.other.variables ) ){
message( x[1]," and ",x[2]," are independent given ",
paste( all.other.variables, collapse=",") )
}
} )
dot <- read.dot("~/Missing data/SERGIO/GNW_sampled_GRNs/Ecoli_100_net1.dot")
g.graph <- graph.adjacency(dot)
plot(g.graph)
g <- graph2dagitty(g.graph)
plot( graphLayout(g) )
# Conditional independencies
impliedConditionalIndependencies(g, type = "missing.edge", max.results = Inf)
# Draw paths from icd to fadI
paths(g, "icd", "fadI" )$paths
# Draw directed paths from icd to fadI
paths(g, "potI", "nemA", directed=TRUE)$paths
plot(g)
#For each pair of non-adjacent nodes in this graph, the set of variables that d-separates that pair.
impliedConditionalIndependencies(g, type = "missing.edge", max.results = Inf)
pairs <- combn( names( g), 2 )
names( g)
graphLayout(g)
g <- graphLayout(g)
#For each pair of non-adjacent nodes in this graph, the set of variables that d-separates that pair.
impliedConditionalIndependencies(g, type = "missing.edge", max.results = Inf)
pairs <- combn( names(g), 2 )
apply( pairs, 2, function(x){
all.other.variables <- setdiff( names(g), x )
if( dseparated(g, x[1], x[2], all.other.variables ) ){
message( x[1]," and ",x[2]," are independent given ",
paste( all.other.variables, collapse=",") )
}
} )
# Draw paths from icd to fadI
paths(g, "icd", "fadI" )$paths
# Draw directed paths from icd to fadI
paths(g, "potI", "nemA", directed=TRUE)$paths
g <- dagitty("dag {
Ux -> X -> Y -> Z <- Uz
Uy -> Y
}")
coordinates(g) <- list(
x=c(Ux=1,Uy=2,Uz=3,X=1,Y=2,Z=3),
y=c(Ux=1,Uy=1,Uz=1,X=0,Y=0,Z=0) )
plot(g)
#For each pair of non-adjacent nodes in this graph, the set of variables that d-separates that pair.
impliedConditionalIndependencies(g, type = "missing.edge", max.results = Inf)
pairs <- combn( names(g), 2 )
apply( pairs, 2, function(x){
all.other.variables <- setdiff( names(g), x )
if( dseparated(g, x[1], x[2], all.other.variables ) ){
message( x[1]," and ",x[2]," are independent given ",
paste( all.other.variables, collapse=",") )
}
} )
g <- dagitty("dag {
X -> R -> S -> T <- U <- V -> Y
T -> P
}")
coordinates(g) <- list(
x=c(Ux=1,Uy=2,Uz=3,X=1,Y=2,Z=3),
y=c(Ux=1,Uy=1,Uz=1,X=0,Y=0,Z=0) )
plot(g)
g<- dagitty("dag {
X -> R -> S -> T <- U <- V -> Y
T -> P
}")
plot(g)
g<-graphLayout(g)
plot(g)
#For each pair of non-adjacent nodes in this graph, the set of variables that d-separates that pair.
impliedConditionalIndependencies(g, type = "missing.edge", max.results = Inf)
# all pairs of variables in the graph that are independent conditional on the set Z={R,V}
paths(g, "X", "Y", c("R","V") )
# Independence of X and Y  given {R,V}
paths(g, "X", "Y", c("R","V") )
# all pairs of variables in the graph that are independent conditional on the set Z={R,V}
pairs <- combn( names(g), 2 )
apply( pairs, 2, function(x){
p <- paths( fig2.5, x[1], x[2], c("R","V") )
if( !p$open ){
message( x[1]," and ",x[2]," are independent given {R,V}" )
} else {
message( x[1]," and ",x[2]," are possibly dependent given {R,V}" )
}
} )
apply( pairs, 2, function(x){
p <- paths(g, x[1], x[2], c("R","V") )
if( !p$open ){
message( x[1]," and ",x[2]," are independent given {R,V}" )
} else {
message( x[1]," and ",x[2]," are possibly dependent given {R,V}" )
}
} )
# for each non-adjacent pair of variables, all minimal sets that we can condition on to render that pair independent.
apply( pairs, 2, function(x){
all.other.variables <- setdiff( names(g), x )
if( dseparated(g, x[1], x[2], all.other.variables ) ){
message( x[1]," and ",x[2]," are independent given ",
paste( all.other.variables, collapse=",") )
}
} )
# for each non-adjacent pair of variables, all minimal sets that we can condition on to render that pair independent.
pairs <- combn( names(g), 2 )apply( pairs, 2, function(x){
# For each pair of non-adjacent nodes in the graph, determine whether they are independent conditional on all other variables.
apply( pairs, 2, function(x){
all.other.variables <- setdiff( names(g), x )
if( dseparated(g, x[1], x[2], all.other.variables ) ){
message( x[1]," and ",x[2]," are independent given ",
paste( all.other.variables, collapse=",") )
}
} )
# For each pair of non-adjacent nodes in the graph, determine whether they are independent conditional on all other variables.
apply( pairs, 2, function(x){
all.other.variables <- setdiff( names(g), x )
if( dseparated(g, x[1], x[2], all.other.variables ) ){
message( x[1]," and ",x[2]," are independent given ",
paste( all.other.variables, collapse=",") )
}
} )
# Conditional independencies
impliedConditionalIndependencies(g, type = "missing.edge", max.results = Inf)
dot <- read.dot("~/Missing data/SERGIO/GNW_sampled_GRNs/Ecoli_100_net1.dot")
g.graph <- graph.adjacency(dot)
plot(g.graph)
plot(g)
dot <- read.dot("~/Missing data/SERGIO/GNW_sampled_GRNs/Ecoli_100_net1.dot")
g.graph <- graph.adjacency(dot)
plot(g.graph)
g <- graph2dagitty(g.graph)
g <- graphLayout(g)
plot(g)
g.graph <- graph.adjacency(dot)
dot <- read.dot("~/Missing data/SERGIO/GNW_sampled_GRNs/Ecoli_100_net1.dot")
g.graph <- graph.adjacency(dot)
g.grapgh''
g.graph
plot(g.graph)
g <- graph2dagitty(g.graph)
g <- graphLayout(g)
plot(g)
# Conditional independencies
impliedConditionalIndependencies(g, type = "missing.edge", max.results = Inf)
N <- 10000 # sample size
Ux <- rnorm( N )
Uy <- rnorm( N )
Uz <- rnorm( N )
X <- Ux
Y <- 1/3*X + Uy
Z <- 1/16*Y + Uz
d <- data.frame(X=X,Y=Y,Z=Z)
g <- dagitty("dag {
Ux -> X -> Y -> Z <- Uz
Uy -> Y
}")
coordinates(g) <- list(
x=c(Ux=1,Uy=2,Uz=3,X=1,Y=2,Z=3),
y=c(Ux=1,Uy=1,Uz=1,X=0,Y=0,Z=0) )
plot(g)
# For each pair of non-adjacent nodes in this graph, the set of variables that d-separates that pair.
# i.e., for each non-adjacent pair of variables, all minimal sets that we can condition on to render that pair independent.
impliedConditionalIndependencies(g, type = "missing.edge", max.results = Inf)
# For each pair of non-adjacent nodes in the graph, determine whether they are independent conditional on all other variables.
pairs <- combn( names(g), 2 )
apply( pairs, 2, function(x){
all.other.variables <- setdiff( names(g), x )
if( dseparated(g, x[1], x[2], all.other.variables ) ){
message( x[1]," and ",x[2]," are independent given ",
paste( all.other.variables, collapse=",") )
}
} )
###########################
g<- dagitty("dag {
X -> R -> S -> T <- U <- V -> Y
T -> P
}")
g<-graphLayout(g)
plot(g)
# For each pair of non-adjacent nodes in this graph, the set of variables that d-separates that pair.
# i.e., for each non-adjacent pair of variables, all minimal sets that we can condition on to render that pair independent.
impliedConditionalIndependencies(g, type = "missing.edge", max.results = Inf)
# Independence of X and Y  given {R,V}
paths(g, "X", "Y", c("R","V") )
# all pairs of variables in the graph that are independent conditional on the set Z={R,V}
pairs <- combn( names(g), 2 )
apply( pairs, 2, function(x){
p <- paths(g, x[1], x[2], c("R","V") )
if( !p$open ){
message( x[1]," and ",x[2]," are independent given {R,V}" )
} else {
message( x[1]," and ",x[2]," are possibly dependent given {R,V}" )
}
} )
# For each pair of non-adjacent nodes in the graph, determine whether they are independent conditional on all other variables.
apply( pairs, 2, function(x){
all.other.variables <- setdiff( names(g), x )
if( dseparated(g, x[1], x[2], all.other.variables ) ){
message( x[1]," and ",x[2]," are independent given ",
paste( all.other.variables, collapse=",") )
}
} )
intersect( predictors, dseparated( fig2.6, "Y", list(), predictors ) )
predictors <- c("X","R","S","T","P")
intersect( predictors, dseparated( fig2.6, "Y", list(), predictors ) )
intersect( predictors, dseparated( g, "Y", list(), predictors ) )
# which of the five variables X,R,S,T,P are d-separated from Y
intersect( predictors, dseparated( g, "Y", list(), predictors ) )
# which of the five variables X,R,S,T,P are d-separated from Y
intersect(predictors, dseparated( g, "Y", list(), predictors)) #Result: X,R,P
# Simulate data
d <- simulateSEM( fig2.6, .7, .7, N=10000 )
# Simulate data
d <- simulateSEM( g, .7, .7, N=10000 )
g
d
head(d)
confint( lm( Y ~ X + R + S + T + P, data=d ) )
fit.lm <- lm( Y ~ X + R + S + T + P, data=d )
confint( fit.lm)
# For each pair of non-adjacent nodes in this graph, the set of variables that d-separates that pair.
# i.e., for each non-adjacent pair of variables, all minimal sets that we can condition on to render that pair independent.
impliedConditionalIndependencies(g, type = "missing.edge", max.results = Inf)
apply( pairs, 2, function(x){
all.other.variables <- setdiff( names(g), x )
if( dseparated(g, x[1], x[2], all.other.variables ) ){
message( x[1]," and ",x[2]," are independent given ",
paste( all.other.variables, collapse=",") )
}
} )
# which of the five variables X,R,S,T,P are d-separated from Y
intersect(predictors, dseparated( g, "Y", list(), predictors)) #Result: X,R,P
# For each pair of non-adjacent nodes in this graph, the set of variables that d-separates that pair.
# i.e., for each non-adjacent pair of variables, all minimal sets that we can condition on to render that pair independent.
impliedConditionalIndependencies(g, type = "missing.edge", max.results = Inf)
# For each pair of non-adjacent nodes in this graph, the set of variables that d-separates that pair.
# i.e., for each non-adjacent pair of variables, all minimal sets that we can condition on to render that pair independent.
impliedConditionalIndependencies(g, type = "missing.edge", max.results = Inf)
# which of the five variables X,R,S,T,P are d-separated from Y given the same five variables
dseparated( g, "Y", list(), predictors
# which of the five variables X,R,S,T,P are d-separated from Y given the same five variables
dseparated( g, "Y", list(), predictors)
# which of the five variables X,R,S,T,P are d-separated from Y given the same five variables
dseparated( g, "Y", list(), predictors)
?dseparated
