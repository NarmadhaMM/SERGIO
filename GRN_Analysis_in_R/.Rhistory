message( x[1]," and ",x[2]," are possibly dependent given {R,V}" )
}
} )
pairs <- combn(y_seq, 2)
apply( pairs, 2, function(x){
p <- paths(g, x[1], x[2], "glnG" )
if( !p$open ){
message( x[1]," and ",x[2]," are independent given {R,V}" )
} else {
message( x[1]," and ",x[2]," are possibly dependent given {R,V}" )
}
} )
# Compute independencies with at most 3 conditioning variables
imp <- Filter(function(x) length(x$Z)<4, impliedConditionalIndependencies(g))
d <- data.frame(d)
CI <- localTests( g, d, "cis.loess", R=100, tests=imp, loess.pars=list(span=0.6) )
plotLocalTestResults (head(CI,10))
plotLocalTestResults (head(CI,10))
CI
plotLocalTestResults (head(CI,10))
dev.off()
plotLocalTestResults (head(CI,10))
dot <- read.dot("~/Missing data/SERGIO/GNW_sampled_GRNs/Ecoli_100_net1.dot")
GRN_out <- read.csv("~/Missing data/SERGIO/Demo/GeneExpression.csv")
GeneIDs <- GeneIDs <- read.delim("~/Missing data/GRN_Analysis/GeneIDs.txt", header=FALSE)
GeneIDs <- gsub(';','',GeneIDs[,2])
# From the GRN network
g.graph <- graph.adjacency(dot)
plot(g.graph)
g <- graph2dagitty(g.graph)
g <- graphLayout(g)
plot(g)
# Conditional independencies
# For each pair of non-adjacent nodes in this graph, the set of variables that d-separates that pair.
# i.e., for each non-adjacent pair of variables, all minimal sets that we can condition on to render that pair independent.
impliedConditionalIndependencies(g, type = "missing.edge", max.results = Inf)
# Draw paths from icd to fadI
paths(g, "icd", "fadI" )$paths
# Draw directed paths from icd to fadI
paths(g, "potI", "nemA", directed=TRUE)$paths
# From the Sergio simulation output
summary(GRN_out)
GRN_out <- t(GRN_out[,-1])
colnames(GRN_out) <-GeneIDs
dim(GRN_out)
head(GRN_out)
# Pearson'd correlation plot
res <- cor(GRN_out)
corrplot::corrplot(res,type = "upper", tl.col = "black", tl.cex = 0.5)
# Conditional independencies from the GRN
true.ind <- impliedConditionalIndependencies(g, type = "missing.edge", max.results = Inf)
pairs <- combn(y_seq, 2)
apply( pairs, 2, function(x){
p <- paths(g, x[1], x[2], "glnG" )
if( !p$open ){
message( x[1]," and ",x[2]," are independent given {R,V}" )
} else {
message( x[1]," and ",x[2]," are possibly dependent given {R,V}" )
}
} )
d <- GRN_out
y_seq <- c("yhdY", "yhdZ")
x_seq <- "glnG"
con.ind(y_seq, x_seq, df=d)
y_seq <- c("ybdN", "ydeA")
x_seq <- "arcA"
con.ind(y_seq, x_seq, df=d)
#########################
# Non-linear regression #
#########################
# Compute independencies with at most 3 conditioning variables
imp <- Filter(function(x) length(x$Z)<4, impliedConditionalIndependencies(g))
d <- data.frame(d)
CI <- localTests( g, d, "cis.loess", R=100, tests=imp, loess.pars=list(span=0.6) )
plotLocalTestResults (head(CI,10))
plotLocalTestResults (head(CI,20))
CI
CI$`2.5%`
CI$`97.5%`
CI$`2.5%` <0 & CI$`97.5%`>0
head(CI,10)
CI[CI$`2.5%` <0 & CI$`97.5%`>0]
CI[CI$`2.5%` <0 & CI$`97.5%`>0]
CI[CI$`2.5%` <0 & CI$`97.5%`>0,]
CI[!(CI$`2.5%` <0 & CI$`97.5%`>0),]
plotLocalTestResults (head(CI[!(CI$`2.5%` <0 & CI$`97.5%`>0),]))
nrow(CI[!(CI$`2.5%` <0 & CI$`97.5%`>0),])
nrow(CI[(CI$`2.5%` <0 & CI$`97.5%`>0),])
ind <- CI[(CI$`2.5%` <0 & CI$`97.5%`>0),]
dep <- CI[!(CI$`2.5%` <0 & CI$`97.5%`>0),]
nrow(ind)
nrow(dep)
plotLocalTestResults (ind)
plotLocalTestResults (dep)
###############################################################
# Conditional independencies of a GRN - Using daggity network #
###############################################################
# Load packages
library(dagitty)
library(lavaan)
library(sna)
library(DOT)
library(igraph)
library(pcalg)
library(SEMgraph)
###########################
### Simulation example 1 ##
###########################
g<- dagitty("dag {
X -> R -> S -> Z <- U <- V -> Y
Z -> P
}")
g<-graphLayout(g)
plot(g)
# For each pair of non-adjacent nodes in this graph, the set of variables that d-separates that pair.
# i.e., for each non-adjacent pair of variables, all minimal sets that we can condition on to render that pair independent.
impliedConditionalIndependencies(g, type = "missing.edge", max.results = Inf)
# Independence of X and Y  given {R,V}
paths(g, "X", "Y", c("R","V") )
# all pairs of variables in the graph that are independent conditional on the set Z={R,V}
pairs <- combn( names(g), 2 )
apply( pairs, 2, function(x){
p <- paths(g, x[1], x[2], c("R","V") )
if( !p$open ){
message( x[1]," and ",x[2]," are independent given {R,V}" )
} else {
message( x[1]," and ",x[2]," are possibly dependent given {R,V}" )
}
} )
# For each pair of non-adjacent nodes in the graph, determine whether they are independent conditional on all other variables.
apply( pairs, 2, function(x){
all.other.variables <- setdiff( names(g), x )
if( dseparated(g, x[1], x[2], all.other.variables ) ){
message( x[1]," and ",x[2]," are independent given ",
paste( all.other.variables, collapse=",") )
}
} )
# Fitting models with fixed effects (no latent variables)
# Y=a+bX+cR+dS+eT+fP
predictors <- c("X","R","S","Z","P")
# Which of the five variables X,R,S,T,P are d-separated from Y given the same five variables
dseparated( g, "Y", list(), predictors)
intersect(predictors, dseparated( g, "Y", list(), predictors)) #Result: X,R,P
# Simulate data
d <- simulateSEM( g, .7, .7, N=10000 )
head(d)
fit.lm <- lm(Y ~ X + R + S + Z + P, data=d )
confint(fit.lm) # Result: X,R,P 95% CIs for coefficients contain zero. The conditional independence is verified.
fit.lm <- lm(Y ~ X +Z , data=d )
confint(fit.lm) # Result: X,R,P 95% CIs for coefficients contain zero. The conditional independence is verified.
###################################################
# Implement a function for conditional dependence #
###################################################
con.ind <- function (Y, X, R){
fit.lm <- lm(Y ~ X +R)
CI <- as.data.frame(confint(fit.lm))
CI$Ind <- with(CI, ifelse(CI$`2.5 %`<0 & CI$`97.5 %`<0 , "Negative conditional dependence",
ifelse(CI$`2.5 %`>0 & CI$`97.5 %`>0 , "Positive conditional dependence",
"Not enough evidence for conditional dependence")))
return(CI["X",])
}
con.ind(d$Y, d$X, d$R)
con.ind <- function (y_seq, x_seq, df){
dtemp.all <- t(combn(y_seq, 2))
for(i in 1:nrow(dtemp.all)){
dtemp <- dtemp.all[i,]
fit.lm <- lm(df[,dtemp[1]] ~ df[,dtemp[2]] + df[,x_seq])
CI <- as.data.frame(confint(fit.lm))
CI$Ind <- with(CI, ifelse(CI$`2.5 %`<0 & CI$`97.5 %`<0 , paste0("Negative conditional dependence given"," ",x_seq),
ifelse(CI$`2.5 %`>0 & CI$`97.5 %`>0 , paste0("Positive conditional dependence given"," ", x_seq),
paste0("Not enough evidence for conditional dependence given", " ", x_seq))))
print(dtemp)
#print(CI)
print(CI["df[, dtemp[2]]","Ind"])
}
#return(CI["d[, dtemp[2]]","Ind"])
}
y_seq <- c("X","Y", "P", "R","S")
x_seq <- "Z" #given
con.ind(y_seq, x_seq, df=d)
fit.lm <- lm(Y ~ X , data=d )
confint(fit.lm)
pairs <- combn( names(g), 2 )
apply( pairs, 2, function(x){
p <- paths(g, x[1], x[2], "Z" )
if( !p$open ){
message( x[1]," and ",x[2]," are independent given Z" )
} else {
message( x[1]," and ",x[2]," are possibly dependent given Z" )
}
} )
##################
### E.coli GRN ###
##################
dot <- read.dot("~/Missing data/SERGIO/GNW_sampled_GRNs/Ecoli_100_net1.dot")
GRN_out <- read.csv("~/Missing data/SERGIO/Demo/GeneExpression.csv")
GeneIDs <- GeneIDs <- read.delim("~/Missing data/GRN_Analysis/GeneIDs.txt", header=FALSE)
GeneIDs <- gsub(';','',GeneIDs[,2])
# From the GRN network
g.graph <- graph.adjacency(dot)
plot(g.graph)
g <- graph2dagitty(g.graph)
g <- graphLayout(g)
plot(g)
# Conditional independencies
# For each pair of non-adjacent nodes in this graph, the set of variables that d-separates that pair.
# i.e., for each non-adjacent pair of variables, all minimal sets that we can condition on to render that pair independent.
impliedConditionalIndependencies(g, type = "missing.edge", max.results = Inf)
# Draw paths from icd to fadI
paths(g, "icd", "fadI" )$paths
# Draw directed paths from icd to fadI
paths(g, "potI", "nemA", directed=TRUE)$paths
# From the Sergio simulation output
summary(GRN_out)
GRN_out <- t(GRN_out[,-1])
colnames(GRN_out) <-GeneIDs
dim(GRN_out)
head(GRN_out)
# Pearson'd correlation plot
res <- cor(GRN_out)
corrplot::corrplot(res,type = "upper", tl.col = "black", tl.cex = 0.5)
# Conditional independencies from the GRN
true.ind <- impliedConditionalIndependencies(g, type = "missing.edge", max.results = Inf)
pairs <- combn(y_seq, 2)
apply( pairs, 2, function(x){
p <- paths(g, x[1], x[2], "glnG" )
if( !p$open ){
message( x[1]," and ",x[2]," are independent given {R,V}" )
} else {
message( x[1]," and ",x[2]," are possibly dependent given {R,V}" )
}
} )
d <- GRN_out
y_seq <- c("yhdY", "yhdZ")
x_seq <- "glnG"
con.ind(y_seq, x_seq, df=d)
y_seq <- c("ybdN", "ydeA")
x_seq <- "arcA"
con.ind(y_seq, x_seq, df=d)
#########################
# Non-linear regression #
#########################
# Compute independencies with at most 3 conditioning variables
imp <- Filter(function(x) length(x$Z)<4, impliedConditionalIndependencies(g))
d <- data.frame(d)
CI <- localTests( g, d, "cis.loess", R=100, tests=imp, loess.pars=list(span=0.6) )
plotLocalTestResults (head(CI,20))
ind <- CI[(CI$`2.5%` <0 & CI$`97.5%`>0),]
dep <- CI[!(CI$`2.5%` <0 & CI$`97.5%`>0),]
nrow(ind)
nrow(dep)
plotLocalTestResults (ind)
plotLocalTestResults (dep)
##################
### E.coli GRN ###
##################
dot <- read.dot("~/Missing data/SERGIO/GNW_sampled_GRNs/Ecoli_100_net1.dot")
GRN_out <- read.csv("~/Missing data/SERGIO/Demo/GeneExpression.csv")
GeneIDs <- GeneIDs <- read.delim("~/Missing data/GRN_Analysis/GeneIDs.txt", header=FALSE)
GeneIDs <- gsub(';','',GeneIDs[,2])
# From the GRN network
g.graph <- graph.adjacency(dot)
plot(g.graph)
g <- graph2dagitty(g.graph)
g <- graphLayout(g)
plot(g)
# Conditional independencies
# For each pair of non-adjacent nodes in this graph, the set of variables that d-separates that pair.
# i.e., for each non-adjacent pair of variables, all minimal sets that we can condition on to render that pair independent.
impliedConditionalIndependencies(g, type = "missing.edge", max.results = Inf)
# Draw paths from icd to fadI
paths(g, "icd", "fadI" )$paths
# Draw directed paths from icd to fadI
paths(g, "potI", "nemA", directed=TRUE)$paths
# From the Sergio simulation output
summary(GRN_out)
GRN_out <- t(GRN_out[,-1])
colnames(GRN_out) <-GeneIDs
dim(GRN_out)
head(GRN_out)
# Pearson'd correlation plot
res <- cor(GRN_out)
corrplot::corrplot(res,type = "upper", tl.col = "black", tl.cex = 0.5)
# Conditional independencies from the GRN
true.ind <- impliedConditionalIndependencies(g, type = "missing.edge", max.results = Inf)
pairs <- combn(y_seq, 2)
apply( pairs, 2, function(x){
p <- paths(g, x[1], x[2], "glnG" )
if( !p$open ){
message( x[1]," and ",x[2]," are independent given {R,V}" )
} else {
message( x[1]," and ",x[2]," are possibly dependent given {R,V}" )
}
} )
plotLocalTestResults (head(CI,20))
dim(d)
nrow(ind)
nrow(dep)
p <- nrow(dep)/nrow(ind)
p
p <- nrow(dep)/(nrow(dep)+nrow(ind))
p
plotLocalTestResults (ind)
plotLocalTestResults (dep)
plotLocalTestResults (head(CI,20))
imp
d <- GRN_out
d <- data.frame(d)
CI <- localTests( g, d, "cis.loess", R=100, tests=imp, loess.pars=list(span=0.6) )
plotLocalTestResults (head(CI,20))
ind <- CI[(CI$`2.5%` <0 & CI$`97.5%`>0),]
dep <- CI[!(CI$`2.5%` <0 & CI$`97.5%`>0),]
plotLocalTestResults (ind)
plotLocalTestResults (dep)
plotLocalTestResults (ind)
# The more samples added, the proportion of detecting correlation when it exists gets higher.
p <- nrow(dep)/(nrow(dep)+nrow(ind))
p
plotLocalTestResults (head(CI,20))
plotLocalTestResults (dep)
install.packages("reticulate")
library(reticulate)
os <- import("os")
os$listdir(".")
source_python("~/Missing data/SERGIO/Demo/sergio.py")
source_python("~/Missing data/SERGIO/Demo/gene.py")
source_python("~/Missing data/SERGIO/Demo/gene.py")
source_python("~/Missing data/SERGIO/Demo/sergio.py")
py_config()
library(reticulate)
os <- import("os")
os$listdir(".")
source_python("~/Missing data/SERGIO/Demo/gene.py")
source_python("~/Missing data/SERGIO/Demo/sergio.py")
use_virtualenv("gene")
import(gene, as = NULL, convert = TRUE, delay_load = FALSE)
dir()
getwd()
#########################
# python from R #
#########################
setwd("C:/Users/moha456/OneDrive - PNNL/Documents/Missing data//SERGIO/Demo")
getwd()
library(reticulate)
os <- import("os")
os$listdir(".")
#use_virtualenv("gene")
source_python("~/Missing data/SERGIO/Demo/gene.py")
#import(gene, as = NULL, convert = TRUE, delay_load = FALSE)
#path <- system.file("python", package = <package>)
source_python("~/Missing data/SERGIO/Demo/sergio.py")
source_python("gene.py")
source_python("sergio.py")
library(reticulate)
os <- import("os")
os$listdir(".")
source_python("gene.py")
source_python("sergio.py")
sim = sergio(number_genes=100, number_bins = 9, number_sc = 300, noise_params = 1, decays=0.8, sampling_state=15, noise_type='dpd')
np <- import("numpy", convert = FALSE)
pd <- import("pandas", convert = FALSE)
sim = sergio(number_genes=100, number_bins = 9, number_sc = 300, noise_params = 1, decays=0.8, sampling_state=15, noise_type='dpd')
?sergio
py_run_file("sergio.py")
?np
sim = sergio(number_genes=100, number_bins = 9, number_sc = 300, noise_params = 1, decays=0.8, sampling_state=15, noise_type='dpd')
import("sergio", convert = FALSE)
sg <- import("sergio", convert = FALSE)
sg
import('sergio.sergio')
sg$sergio
sim = sg$sergio(number_genes=100, number_bins = 9, number_sc = 300, noise_params = 1, decays=0.8, sampling_state=15, noise_type='dpd')
?sg$sergio
py_run_file("sergio.py")
library(reticulate)
setwd("C:/Users/moha456/OneDrive - PNNL/Documents/Missing data//SERGIO/Demo")
os <- import("os")
os$listdir(".")
source_python("gene.py")
source_python("sergio.py")
py_run_file("sergio.py")
np <- import("numpy", convert = FALSE)
pd <- import("pandas", convert = FALSE)
sg <- import("sergio", convert = FALSE)
sim = sg$sergio(number_genes=100, number_bins = 9, number_sc = 300, noise_params = 1, decays=0.8,
sampling_state=15, noise_type='dpd')
sim = sg$sergio(number_genes=100, number_bins = 9, number_sc = 300, noise_params = 1, decays=0.8,
sampling_state=15)
sim = sg$sergio(number_genes=100, number_bins = 9, number_sc = 300, noise_params = 1, decays=0.8,
sampling_state=15, noise_type='dpd')
sg
sg$sergio
sergio$build_graph
?sergio$build_graph
typeof(sergio)
sergip
sergio
sim = sergio(number_genes=100, number_bins = 9, number_sc = 300, noise_params = 1, decays=0.8,
sampling_state=15, noise_type='dpd')
sim = sergio(number_genes=100, number_bins = 9, number_sc = 300, noise_params = 1, decays=1,
sampling_state=15, noise_type='dpd')
use_python("C:/Users/moha456/Anaconda3/python")
use_python("C:/Users/moha456/Anaconda3")
library(reticulate)
library(reticulate)
setwd("C:/Users/moha456/OneDrive - PNNL/Documents/Missing data//SERGIO/Demo")
use_python("C:/Users/moha456/Anaconda3")
os <- import("os")
os$listdir(".")
source_python("gene.py")
source_python("sergio.py")
np <- import("numpy", convert = FALSE)
pd <- import("pandas", convert = FALSE)
sim = sergio(number_genes=100, number_bins = 9, number_sc = 300, noise_params = 1, decays=0.8,
sampling_state=15, noise_type='dpd')
py_function <- py_function("sergio", "sergio.py")
sergio
sergio$build_graph
py_run_string(sergio)
sg <- import("sergio", convert = FALSE)
py_run_string(sg$sergio)
py_run_file(sergio)
py_run_file(sergio.py)
py_run_file("sergio.py")
out <- py_run_file("sergio.py")
print(out)
sim = sergio(number_genes=100, number_bins = 9, number_sc = 300, decays=0.8,
sampling_state=15, noise_type='dpd')
sim = sergio(number_genes=100,  noise_params = 1, decays=0.8,
sampling_state=15, noise_type='dpd')
sim = sergio(number_genes=100, number_bins = 9, number_sc = 300, noise_params = 1, decays=0.8,
noise_type='dpd')
sim = sergio(number_genes=100, number_bins = 9, number_sc = 300, noise_params = 1, decays=1,
sampling_state=15, noise_type='dpd')
cat(py_to_r(paste("print(inspect.getsource(", sergio, "))")))
cat(py_to_r(paste("print(inspect.getsource(", sg$sergio, "))")))
\
py_new("sergio", number_genes=100, number_bins = 9, number_sc = 300, noise_params = 1, decays=1,
sampling_state=15, noise_type='dpd')
py_call("sergio", number_genes=100, number_bins = 9, number_sc = 300, noise_params = 1, decays=1,
sampling_state=15, noise_type='dpd')
sergio()
sergio
os <- import("os")
os$listdir(".")
source_python("gene.py")
source_python("sergio.py")
#out <- py_run_file("sergio.py")
np <- import("numpy", convert = FALSE)
pd <- import("pandas", convert = FALSE)
sg <- import("sergio", convert = FALSE)
sg$sergio
sg$sergio()
sg$sergio(number_genes=100, number_bins = 9, number_sc = 300, noise_params = 1, decays=1, noise_type='dpd')
np
print(sg$sergio)
as.integer(100)
sg$sergio(number_genes= as.integer(100), number_bins = as.integer(9), number_sc = as.integer(300),
noise_params = as.integer(1), decays= as.integer(1), noise_type='dpd')
sim = sg$sergio(number_genes= as.integer(100), number_bins = as.integer(9), number_sc = as.integer(300),
noise_params = as.integer(1), sampling_state=15, decays= as.integer(1), noise_type='dpd')
sim = sg$sergio(number_genes= as.integer(100), number_bins = as.integer(9), number_sc = as.integer(300),
noise_params = as.integer(1), sampling_state=15, decays= 0.8, noise_type='dpd')
sim = sg$sergio(number_genes= as.integer(100), number_bins = as.integer(9), number_sc = as.integer(300),
noise_params = 1, sampling_state=15, decays= 0.8, noise_type='dpd')
sim$build_graph(input_file_taregts ='steady-state_input_GRN.txt', input_file_regs='steady-state_input_MRs.txt', shared_coop_state=2)
sim$simulate()
expr = sim$getExpressions()
expr_clean_ss = np$concatenate(expr, axis = 1)
expr
expr_clean_ss = np$concatenate(expr, axis = 1)
expr_clean_ss = np$concatenate(expr, axis = as.integer(1))
head(expr_clean_ss)
library(reticulate)
setwd("C:/Users/moha456/OneDrive - PNNL/Documents/Missing data//SERGIO/Demo")
use_python("C:/Users/moha456/Anaconda3")
os <- import("os")
os$listdir(".")
# Sourcing python scripts
source_python("gene.py")
source_python("sergio.py")
# Import modules
np <- import("numpy", convert = FALSE)
pd <- import("pandas", convert = FALSE)
sg <- import("sergio", convert = FALSE)
# Simulate Clean Data _ Steady State Simulation for single cell data
sim = sg$sergio(number_genes= as.integer(100), number_bins = as.integer(9), number_sc = as.integer(300),
noise_params = 1, sampling_state=15, decays= 0.8, noise_type='dpd')
sim$build_graph(input_file_taregts ='single_cell_GRN.txt', input_file_regs='single_cell_MRs.txt', shared_coop_state=2)
# Simulate Clean Data _ Steady State Simulation for single cell data
sim = sg$sergio(number_genes= as.integer(100), number_bins = as.integer(1), number_sc = as.integer(300),
noise_params = 1, sampling_state=15, decays= 0.8, noise_type='dpd')
sim$build_graph(input_file_taregts ='single_cell_GRN.txt', input_file_regs='single_cell_MRs.txt', shared_coop_state=2)
sim$simulate()
expr = sim$getExpressions()
expr_clean_ss = np$concatenate(expr, axis = as.integer(1))
head(expr_clean_ss)
# Sourcing python scripts
source_python("gene.py")
source_python("sergio.py")
# Import modules
np <- import("numpy", convert = FALSE)
pd <- import("pandas", convert = FALSE)
sg <- import("sergio", convert = FALSE)
# Simulate Clean Data _ Steady State Simulation for single cell data
sim = sg$sergio(number_genes= as.integer(100), number_bins = as.integer(9), number_sc = as.integer(300),
noise_params = 1, sampling_state=15, decays= 0.8, noise_type='dpd')
sim$build_graph(input_file_taregts ='steady-state_input_GRN.txt', input_file_regs='steady-state_input_MRs.txt', shared_coop_state=2)
sim$simulate()
expr = sim$getExpressions()
expr_clean_ss = np$concatenate(expr, axis = as.integer(1))
head(expr_clean_ss)
